package task3;

import task3.implementation.*;
import task3.specification.*;

import java.util.ArrayList;
import java.util.logging.Logger;

public class MessageQueueTest {

    public static final int PORT = 6923;
    public static final int NUMBER_OF_MESSAGES = 10;
    public static final Logger logger = Logger.getLogger(MessageQueueTest.class.getName());

    public static void main(String[] args) {

        logger.info("MessageQueueTest started.");
        // Initialize BrokerManager to handle both sender and receiver brokers
        BrokerManager.getInstance();
        logger.info("BrokerManager initialized.");

        // Initialize the EventPump
        EventPump eventPump = new EventPumpImpl();
        logger.info("EventPump initialized.");

        // Create QueueBrokers for sender and receiver
        QueueBroker senderQueueBroker = new QueueBrokerImpl("senderBroker");
        QueueBroker receiverQueueBroker = new QueueBrokerImpl("receiverBroker");
        logger.info("QueueBrokers created.");

        // Start the MessageReceiver and MessageSender threads
        MessageReceiver receiverTester = new MessageReceiver(receiverQueueBroker, eventPump);
        MessageSender senderTester = new MessageSender("Hello from MessageQueueTest!",
                "receiverBroker", eventPump, senderQueueBroker);
        logger.info("MessageReceiver and MessageSender Event-based tasks created.");


        // Start the EventPump
        eventPump.start();
        logger.info("EventPump started.");

        // Running the tasks
        while (!ETask.runningTasks.isEmpty()) {
            synchronized (ETask.runningTasks) {
                for (ETask task : new ArrayList<>(ETask.runningTasks)) {
                    if (task != null && !task.killed()) {
                        task.run();
                    }
                }
            }
        }

        eventPump.kill();

        System.out.println("MessageQueueTest completed successfully.");
    }
}package task3;

import task3.specification.*;

public class MessageReceiver extends ETask implements Runnable{

    private final QueueBroker queueBroker;
    private volatile MessageQueue messageQueue;
    private volatile State state;


    // Message Counters
    private volatile int receivedMessages = 0;
    private final int totalMessagesToSend = MessageQueueTest.NUMBER_OF_MESSAGES;

    enum State {
        INIT,WAITING_CONNECTION,SETTING_LISTENER,CONNECTED, FINISHED, DISCONNECTING, DEAD
    }

    public MessageReceiver(QueueBroker queueBroker, EventPump pump) {
        super(pump);
        this.queueBroker = queueBroker;
        this.state = State.INIT;
    }

    private QueueBroker getQueueBroker() {
        return this.queueBroker;
    }

    private int getPort() {
        return MessageQueueTest.PORT;
    }

    /**
     * Establish connection by creating a MessageQueue to communicate with the sender.
     */
    public void establishConnection() {
        getQueueBroker().bind(getPort(), new QueueBroker.AcceptListener() {
            @Override
            public void accepted(MessageQueue messageQueue) {
                MessageReceiver.this.messageQueue = messageQueue;
            }
        });
    }

    /**
     * Echoes the received message back to the sender.
     */
    private void echoMessage(byte[] message) {
        if (state != State.CONNECTED) {
            return;
        }
        System.out.println("<-- MessageReceiver received message " + receivedMessages);
        receivedMessages++;
        messageQueue.send(message); // Send back the same message
        if (receivedMessages == totalMessagesToSend) {
            this.state = State.FINISHED;
        }
    }

    @Override
    public void run() {
        switch (state) {
            case INIT:
                establishConnection();
                state = State.WAITING_CONNECTION;
                break;
            case WAITING_CONNECTION:
                if (messageQueue != null) {
                    state = State.SETTING_LISTENER;
                }
                break;
            case SETTING_LISTENER:
                // Set the Listener for receiving messages
                messageQueue.setListener(new MessageQueue.Listener() {
                    @Override
                    public void received(byte[] msg) {
                        echoMessage(msg);
                    }

                    @Override
                    public void closed() {
                        state = State.DISCONNECTING;
                    }

                });
                state = State.CONNECTED;
                MessageQueueTest.logger.info("MessageReceiver is connected and listening");
                break;

            case FINISHED:
                if (receivedMessages == totalMessagesToSend) {
                    System.out.println("MessageReceiver received and echoed all messages");
                    state = State.DISCONNECTING;
                }
                break;
            case DISCONNECTING:
                MessageQueueTest.logger.info("MessageReceiver is disconnecting");
                queueBroker.unbind(getPort());
                state = State.DEAD;
                break;
            case DEAD:
                MessageQueueTest.logger.info("MessageReceiver is dead");
                this.kill();
                break;
            default:
                break;
        }
    }
}package task3;

import task3.specification.*;

public class MessageSender extends ETask implements Runnable {

    private final QueueBroker queueBroker;
    private volatile MessageQueue messageQueue;
    private final String receiverBrokerName;
    private final String message;
    private volatile State state;
    private boolean testPassed = true;

    // Message Counters
    private int receivedMessages = 0;
    private int sentMessages = 0;
    private int totalMessagesToSend = MessageQueueTest.NUMBER_OF_MESSAGES;

    enum State {
        INIT, WAITING_CONNECTION, SETTING_LISTENER, FINISHED, CONNECTED, DISCONNECTING, DEAD
    }

    public MessageSender(String message, String receiverBrokerName, EventPump pump, QueueBroker queueBroker) {
        super(pump);
        this.queueBroker = queueBroker;
        this.receiverBrokerName = receiverBrokerName;
        this.message = message;
        this.state = State.INIT;
    }

    private QueueBroker getQueueBroker() {
        return this.queueBroker;
    }

    private int getPort() {
        return MessageQueueTest.PORT;
    }

    /**
     * Establish connection by creating a MessageQueue to communicate with the receiver.
     */
    public void establishConnection() {
        getQueueBroker().connect(receiverBrokerName, getPort(), new QueueBroker.ConnectListener() {
            @Override
            public void connected(MessageQueue messageQueue) {
                MessageSender.this.messageQueue = messageQueue;
            }

            @Override
            public void refused() {
                System.out.println("Failed to establish connection in MessageSender");
                state = State.DISCONNECTING;
            }
        });
    }

    /**
     * Sends the message through the MessageQueue.
     */
    private void sendMessage() {
        if (sentMessages == totalMessagesToSend) {
            state = State.FINISHED;
            MessageQueueTest.logger.info("MessageSender finished sending messages");
            return;
        }
        if (state == State.CONNECTED && messageQueue != null && sentMessages < totalMessagesToSend) {
            System.out.println("--> Sending message "+ this.sentMessages +" : " + message);
            this.sentMessages++;
            messageQueue.send(message.getBytes());
        }
    }

    @Override
    public void run() {
        switch (state) {
            case INIT:
                establishConnection();
                state = State.WAITING_CONNECTION;
                break;

            case WAITING_CONNECTION:
                if (messageQueue != null) {
                    state = State.SETTING_LISTENER;
                }
                break;

            case SETTING_LISTENER:
                // Set the listener for receiving any responses or connection status changes
                messageQueue.setListener(new MessageQueue.Listener() {
                    @Override
                    public void received(byte[] msg) {
                        testPassed = testPassed && new String(msg).equals(message);
                        System.out.println("--> Echo "+ receivedMessages +" received and matched");
                        receivedMessages++;
                    }

                    @Override
                    public void closed() {
                        state = State.DISCONNECTING;
                    }
                });
                state = State.CONNECTED;
                MessageQueueTest.logger.info("MessageSender is connected and listening");
                break;

            case CONNECTED:
                sendMessage(); // Send message only when connected
                break;

            case FINISHED:
                if (testPassed && receivedMessages == totalMessagesToSend) {
                    System.out.println("MessageSender test passed");
                    state = State.DISCONNECTING;
                }
                break;

            case DISCONNECTING:
                MessageQueueTest.logger.info("MessageSender is disconnecting");
                state = State.DEAD;
                break;
            case DEAD:
                MessageQueueTest.logger.info("MessageSender is dead");
                this.kill();
                break;
            default:
                break;
        }
    }
}